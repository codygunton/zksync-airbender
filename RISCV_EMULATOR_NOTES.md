# ZKSync Airbender RISC-V Emulator Notes

## RISC-V Emulator/Executor Identification

The RISC-V emulator is located in the `risc_v_simulator` crate at `/home/cody/zksync-airbender/risc_v_simulator/`.

Key characteristics:
- Implements RV32IM basic instruction set (32-bit RISC-V with Integer and Multiply/Divide extensions)
- Supports machine mode and user mode (no atomic instructions)
- Entry point: `DEFAULT_ENTRY_POINT: u32 = 0x01000000` (defined in risc_v_simulator/src/runner/mod.rs)
- Inspired by https://github.com/cnlohr/mini-rv32ima but written in Rust

## Build Command

**Verified cargo command to build the emulator:**

```bash
cd /home/cody/zksync-airbender/risc_v_simulator
cargo build --release
```

The build command successfully compiles the emulator with default features enabled:
- `field` feature
- `delegation` feature (includes blake2s_u32, field, poseidon2, ruint)

## Testing Infrastructure

### 1. Unit Tests for Individual Instructions
Located in `/home/cody/zksync-airbender/risc_v_simulator/src/tests/`:
- Tests for individual opcodes: add.rs, addi.rs, mul.rs, mulh.rs, etc.
- Uses `lib-rv32-asm` crate (from https://github.com/shamatar/lib-rv32.git) for assembling instructions
- Test framework uses helper functions like `test_reg_reg_op` and `test_reg_imm_op` defined in mod.rs

### 2. RISC-V Compliance Test Suite (riscv_ctg)
Located in `/home/cody/zksync-airbender/circuit_defs/opcode_tests/src/data/`:
- Contains RISC-V Compliance Test Group (CTG) generated test files
- Files are in assembly format (.S extension)
- Generated by riscv_ctg tool (https://gitlab.com/incoresemi/riscv-compliance/riscv_ctg)
- Version: 0.4.1 (timestamp: Tue Dec 15 15:36:11 2020 GMT)

Test files include:
- add-01.S, addi-01.S, and-01.S, andi-01.S
- beq-01.S, bge-01.S, bgeu-01.S, blt-01.S, bltu-01.S, bne-01.S
- div-01.S, divu-01.S
- jal-01.S, jalr-01.S
- lb-align-01.S, lbu-align-01.S, lh-align-01.S, lhu-align-01.S, lw-align-01.S
- mul-01.S, mulh-01.S, mulhsu-01.S, mulhu-01.S
- rem-01.S, remu-01.S
- And many more...

## Test Compilation Process

### Assembly Test Processing
The opcode tests are **NOT compiled as separate ELF files**. Instead:

1. **Test files are embedded as strings** at compile time using `include_str!` macro
   - Example: `const TESTCASES: &str = include_str!("../data/add-01.S");`

2. **Test parsing happens at runtime:**
   - Tests parse the embedded .S files looking for specific test patterns (e.g., `TEST_RR_OP`)
   - Extract operands and expected values from test macros
   - Use `lib-rv32-asm` to assemble individual instructions dynamically

3. **Header Dependencies:**
   - Tests reference `model_test.h` and `arch_test.h` but these are not present
   - The test framework doesn't require these headers as it parses tests directly

### Binary Loading for Execution

The simulator can load and execute:
1. **Raw binary files** (.bin) - loaded directly into memory at entry point
2. **ELF files** (.elf) - used for symbol information and debugging

Example usage from CLI tool:
```bash
# Run a binary
cargo run --profile cli run --bin app.bin

# Generate proof for a binary
cargo run --profile cli prove --bin app.bin --output_dir output/
```

### Compilation of User Programs

For user programs (like those in examples/):

**Build Configuration (.cargo/config.toml):**
```toml
[build]
target = "riscv32i-unknown-none-elf"
rustflags = [
  "-C", "target-feature=+m,-unaligned-scalar-mem,+relax",
  "-C", "link-arg=-T../scripts/lds/memory.x",
  "-C", "link-arg=-T../scripts/lds/link.x",
  "-C", "link-arg=--save-temps",
  "-C", "force-frame-pointers",
]
```

**Linker Scripts Used:**
- `memory.x`: Defines memory regions (ROM at 0x0, RAM at 2M)
- `link.x`: Defines section layout, stack allocation (64M per hart), heap (768M)

**Build Process:**
```bash
# Build Rust no_std program to RISC-V target
cargo build --release

# Extract binary from ELF
cargo objcopy --release -- -O binary app.bin

# Extract text section only
cargo objcopy --release -- -O binary --only-section=.text app.text
```

## Key Implementation Details

- **Memory Model:** Uses `VectorMemoryImpl` for simulation memory
- **State Management:** Two implementations:
  - `RiscV32State` - original simulator
  - `RiscV32StateForUnrolledProver` - optimized for ZK proving
- **No MMU by default:** Uses `NoMMU` struct (memory management unit disabled)
- **Non-determinism:** Handled via "quasi-UART" oracle interface for ZK witness data

## Notes on RISC-V Test Compatibility

The system does NOT use standard riscv-tests or riscv-arch-tests ELF files directly. Instead:
- It has its own test infrastructure based on riscv_ctg generated assembly
- Tests are embedded and assembled on-the-fly during testing
- No separate compilation step with gcc/as/ld for tests
- Test assembly macros (TEST_RR_OP, RVTEST_*, RVMODEL_*) are parsed but not preprocessed
- User programs ARE compiled with linker scripts (memory.x and link.x) using Rust's RISC-V target
- The distinction: opcode tests are dynamically assembled, user programs are properly linked

## Compiling External .S Files

### Prerequisites

You'll need a RISC-V cross-compilation toolchain. Options include:

1. **Rust's LLVM toolchain** (already available if you have Rust installed):
   - Located at: `~/.rustup/toolchains/stable-*/lib/rustlib/*/bin/`
   - Tools: `llvm-as`, `llvm-ld`, `llvm-objcopy`

2. **GNU RISC-V Toolchain** (optional, for traditional approach):
   - Install: `riscv32-unknown-elf-gcc`, `riscv32-unknown-elf-as`, `riscv32-unknown-elf-ld`
   - Or: `riscv64-unknown-elf-*` tools with `-march=rv32im` flag

### Method 1: Using Rust/LLVM Toolchain (Recommended)

```bash
# 1. Assemble .S file to object file
llvm-as --target=riscv32 -march=rv32im input.S -o input.o

# 2. Link with the provided linker scripts
llvm-ld \
  -T examples/scripts/lds/memory.x \
  -T examples/scripts/lds/link.x \
  input.o \
  -o output.elf

# 3. Extract binary for the emulator
llvm-objcopy -O binary output.elf output.bin
```

### Method 2: Using GNU RISC-V Toolchain

```bash
# 1. Assemble and link in one step
riscv32-unknown-elf-gcc \
  -march=rv32im \
  -mabi=ilp32 \
  -nostdlib \
  -nostartfiles \
  -T examples/scripts/lds/memory.x \
  -T examples/scripts/lds/link.x \
  input.S \
  -o output.elf

# 2. Extract binary
riscv32-unknown-elf-objcopy -O binary output.elf output.bin
```

### Method 3: Manual Assembly and Linking

```bash
# 1. Preprocess (if using macros)
riscv32-unknown-elf-gcc -E -march=rv32im input.S -o input.i

# 2. Assemble
riscv32-unknown-elf-as -march=rv32im input.i -o input.o

# 3. Link
riscv32-unknown-elf-ld \
  -T examples/scripts/lds/memory.x \
  -T examples/scripts/lds/link.x \
  input.o \
  -o output.elf

# 4. Extract binary
riscv32-unknown-elf-objcopy -O binary output.elf output.bin
```

### Important Considerations

**Memory Layout (from memory.x):**
- **ROM**: 0x00000000 - 0x001FFFFF (2MB)
- **RAM**: 0x00200000 - 0x3FFFFFFF (1022MB)
- **Entry Point**: Defaults to 0x01000000 (16MB offset)

**Required Compiler Flags:**
- **Architecture**: `-march=rv32im` (32-bit RISC-V with Integer and Multiply extensions)
- **ABI**: `-mabi=ilp32` (32-bit integer ABI)
- **No standard libraries**: `-nostdlib -nostartfiles` (bare metal environment)

### For Test Assembly Files (from circuit_defs/opcode_tests/)

If compiling the riscv_ctg test files:

```bash
# These files include macros that need preprocessing
# You'll need to provide definitions for:
# - RVTEST_ISA
# - RVMODEL_BOOT
# - RVTEST_CODE_BEGIN/END
# - TEST_RR_OP and other test macros

# Minimal compilation (without macro expansion):
riscv32-unknown-elf-as \
  -march=rv32im \
  --defsym RVTEST_ISA=RV32I \
  test.S \
  -o test.o
```

Note: The test macros (TEST_RR_OP, RVTEST_*, RVMODEL_*) would need to be defined or the files preprocessed with appropriate headers for full compilation.

### Running the Binary

Once compiled to `.bin` format:

```bash
# Using the CLI tool
cargo run --profile cli run --bin output.bin

# Or directly with the simulator
cargo run --bin runner -- output.bin
```

### Verification

To verify your binary was compiled correctly:

```bash
# Disassemble to check instructions
llvm-objdump -d output.elf

# Or with GNU tools
riscv32-unknown-elf-objdump -d output.elf

# Check binary size and layout
xxd -l 64 output.bin  # View first 64 bytes in hex
```